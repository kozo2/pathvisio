RFC: Gene database & Gex API

This RFC is there to solve these problems:

1. You can load only one gene database per time, however, it would be nice to be able to 
use a gene database and a metabolite database side by side.

2. The current class interface for accessing Gdb & Gex is not well defined, 
for the future we should have a stable API.

3. Modeless caching: the data caching on pathway load popup can be improved, 
a modeless, threaded implementation is preferable.

Roadmap
=======

Step 1: discuss this RFC
Step 2: write class structure with (empty) methods, write javadoc
Step 3: write implementation
in parallel with
Step 4: write unit tests

Step 5: mark old functions as deprecated with pointer to new functions
Step 6: remove deprecated functions one by one. Check that all functionality is covered in new API.

These classes should all be in package org.pathvisio.data

I propose to do a test implementation first in 
	
package org.pathvisio.newdata;

and later move it to

package org.pathvisio.data;

That way the current and future implementations can live side by side
until we are sure that the new implementation is at least as good as the
current one.

The unit tests should include speed tests for the old and new system so we
can prevent performance regressions.

The implementation will work both with Gdb schema 2 and 3 (See rfc 010-gdb-schema-update)

Naming conventions
==================

System Code <-> Data Source

Data Source is used in GPML.
System Code is used in GenMAPP.

I propose to use Data Source for the concept in general (i.e. a resource for linking pathway datanodes to expression data), 
and SystemCode only when you refer to the one or two letter code such as 'En' or 'L'.

Interface
=========

Package overview documentation:

Gex / Gdb are both interfaces.
They are implemented by various different RDBMS-specific classes, such as
DerbyDb, HsqlDb, etc.
Most of these will implement both the Gex and the Gdb interface together, but
this is not necessary.

### TODO: how does SimpleGdb relate to different database implementations (Derby, MySQL, etc.) 
### Do they simply extend it?

DataSource.java
---------------
/**
	contains information about a certain DataSource, e.g.
	
	Extenisble enum pattern.
	You can't instantiate this directly, instead you have to use the "getBySystemcode" or "getByFullname" methods.
	These methods return a predefined DataSource object if it exists, or create a new one if necessary.
	
	This way any number of pre-defined DataSources can be used, but plugins can define new ones and you can
	handle unknown systemcodes that occur in Gpml in the same way as predefined ones.
	
	PathVisio should never have to refer to system codes as Strings, except
	- in low level SQL code dealing with Gdb's, Gex and MAPP's (MAPPFormat.java)
	- in low level GPML code (GPMLFormat.java)
*/
public class DataSource
{
	/** turn id into url pointing to info page on the web, e.g. "http://www.ensembl.org/get?id=ENSG..." */
	public Url getUrl(String id); 
	
	/** returns full name of datasource e.g. "Ensembl". May return null. Also used as identifier in GPML */
	public String getFullname(); 
	
	/** returns GenMAPP SystemCode, e.g. "En". May return null. */
	public String getSystemCode(); 
	
	/** so new system codes can be added easily by plugins. Pattern and url may be null */
	public static void register(String fullName, String sysCode, String Pattern, String url);
	
	/** returns pre-existing DataSource object by system code, if it exists, or creates a new one */
	public static DataSource getBySystemCode(String systemCode);

	/** returns pre-existing DataSource object by system code, if it exists, or creates a new one */
	public static DataSource getByFullName(String fullName);
	
	/**
		get all registered datasoures as a set
		There is no function to get systemcodes or full names as a list of strings, 
		because it's hard to guarantee the ordering, which is needed for combobox controls.
	*/ 
	static public Set<DataSource> getDataSources()
	
}

There are always other parameters for each DataSource that should be stored outside DataSource
e.g. EuGene names.
(The EuGene exporter should be a plugin, so DataSource can't know about it)
As an example of how this should be done, I propose to put regex patterns in a separate class


/**
Collection of regular expressions for identifying a type of systemcode, e.g. "ENSG\d+" for Ensembl

This is an example of how you should define meta-data for a DataSource. 
One important design principle here is that these external data should map to a DataSource object, 
not a System code, so that system codes are used as little as possible, and it is impossible
to define information on a DataSource that DataSource doesn't know about.
*/
public class DataSourcePatterns
{
	/** 
		get a pattern. Returns null if this pattern was never registered. 
		This method is private, since it is only needed by guessDataSource.
		But other datasource extensions may make this method public.
	*/
	static private Pattern getPattern (DataSource src)
	
	/**
		Uses all registered patterns to guess which datasource the id belongs to.
		Returns null if no registered pattern matched.
		This is a best guess, and does not guarantee to give the right choice
	*/
	static public DataSource guessDataSource(String id)
	
	/** 
		To set a pattern for e.g. Ensembl, do:
		DataSourcePatterns.registerPattern (DataSource.getBySystemCode ("En"), Pattern.compile("ENSG\d+"));
		Fails with IllegalArgumentException if you try to set a pattern on a null DataSource.
		Since you can't instantiate DataSource directly, it's impossible to set a Pattern 
		on a non-registered datasource.
	*/
	static public void registerPattern (DataSource src, Pattern p)
}

IdCodePair.java
---------------
### TODO: IdCodePair -> good name? Code does not directly refer to datasource
### Maybe GDBReference or just Reference is a better name?
### I like reference. 
### That gives me a new idea: XRef, because it is consistent with what it is called inside GPML.

/**
Pair of DataSource and identifier.
Points to a particular data item in a particular database.
*/
public class XRef
{
	public DataSource getDataSource()
	public void setDataSource (DataSource value)
	
	public String getId()
	public void setId (String value)
	
	public XRef (String id, DataSource ds)
	
	// convenience method
	public Url getUrl ()
	{
		return ds.getUrl(id);
	}
}

Gdb.java
--------
/**
	Abstract interface for dealing with any system that can map from one DataSource to another.
	
	Implemented by: single (derby) database, aggregate database.
	Possible future implemenatations: xml-rpc, direct ensembl lookup... DAVID lookup... 
	Implementations of the Gdb interface do not necessarily need to use a relational database directly.
*/
abstract interface Gdb
{
	/**
	get all cross-references
	*/
	List<IdCodePair> getCrossReferences(IdCodePair icp) throws GdbException
	
	/**
	get cross-references in the target datasource
	(if the target datasource is known the query can usually be optimized)
	*/
	List<IdCodePair> getCrossReferences(IdCodePair icp, DataSource targetDs) throws GdbException
	
	
	/** get a name for this database, e.g. "Hs_Ens_43" */
	String getGdbName()
}

GdbException.java
-----------------
/**
	Simple wrapper so using classes don't need to deal with implemenation details
	of the Gdb. Usually wraps SQLException, ClassNotFoundException, etc.
	
	Simply use the inherited constructor GdbException(Throwable cause)
	to wrap an exception.
*/
class GdbException extends Exception
{
}

AggregateGdb.java
-----------------
/**
AggregateGdb: multiple simple Gdb's can be bound together
*/
class AggregateGdb implements Gdb
{
	/**
		constructor, start with empty aggregate
	*/
	public AggregateGdb()
	
	/**
		let a SimpleGdb be registered within the aggregate
	*/
	public void register (SimpleGdb gdb)
	
	@override
	public List<IdCodePair> getCrossReferences(IdCodePair icp, DataSource targetDs) throws GdbException

	@override
	public List<IdCodePair> getCrossReferences(IdCodePair icp) throws GdbException
}

SimpleGdb.java
--------------
/**
	Simple Gdb is implemented
	using a JDBC Driver. 
	It takes a JDBC connection string as constructor argument.
	Depending on the current preference, 

### TODO: is this similar to the old DBConnector class?
*/
class SimpleGdb implements Gdb
{
### TODO: which of these DbConnector methods need to be copied?
	createTables()
	createNewDatabase()
	createIndices()
	compact()
	
### TODO: is an isConnected() method necessary, or is that only because Gdb is static in the current PathVisio?

	/**
		list all available data sources
		(package private method, used by aggregateGdb to find the most suited simpleGdb)
	*/
	Set<DataSource> getAvailableDataSources ()
	
	/**
		Constructor from file
	*/

	SimpleGdb (String connectionString) throws GdbException

	@override
	List<IdCodePair> getCrossReferences(IdCodePair icp, DataSource targetDs) throws GdbException

	@override
	List<IdCodePair> getCrossReferences(IdCodePair icp) throws GdbException
}


// This is the current Gex.importFromTxt combined with ImportInformation.
class GexTxtImport
{
	getFile()
	setFile()
	getMaximum()
	getMinimum()
	
	List<String> getErrors()
	
	getDataSource()
	setDataSource()
	getSysCodeColumn()
	setSysCodeColumn()
	getIdColumn()
	setIdColumn()
	getDelimiter
	setDelimiter
	getNoHeader
	setNoHeader
	getColNames
	setStringCols
	getStringCols
	getHeaderStart
	setHeaderStart
	getHeaderEnd
	setHeaderEnd
	getDataStart
	setDataStart
	
	/**
	read a part, for guessing
	*/
	readPart
	
	guessDelimiter
	guessStringCols
	guessSysCodeColumn
	guessSysCode
	guessIdColumn
	
	/**
	perform the actual import. may be cancelled
	*/
	void doImport (ProgressKeeper p, Gex gex)
	{
	}
}

Gex.java
--------
abstract interface Gex
{
	/**
		returns all data for this codepair and column, 
		mapped by code pair as it is in the expression data.
	*/
### TODO: return type? We need a two-dimensional map, since there are multiple
### samples in our data row. I propose to use the DataRow object (see below)
/*
	A Map is too simple as return type. Our data consists of:
	- x samples
	- group number
*/
	Map<IdCodePair, DataRow> getData (IdCodePair, String sampleColumn)
}

/**
Represents a row of data
*/
class DataRow 
{
	IdCodePair icp; //The original id/code for this row in the database
	Map<Sample, Object> columns;
	
	public Object getValue(Sample sample) 
	{
		return columns.get(sample);
	}
}

// NOTE: same as current Gex.Sample
class Sample implements Comparable<Sample>
{
	public String getName()
	public int getDataType()
	public int getId()
	public int hashCode();
	public boolean equals (Object o)
	public String toString()
}

### TODO: do we need to define data events for mapping newly added genes, caching?
### To cache newly added genes, Gex needs to listen to the model for newly added DataNodes.
### We only need a way to make a DataNode redraw itself after caching is done for that node.
### This needs to be done without the View having notion of Gex and preferably without Gex
### having notion of the view.

Use case: Mapping data to genes
===============================

Step 1:

### TODO...

Step 2:

AggregateGdb will execute this query for each registered Gdb, and aggregate the results.
It will use getAvailableDatasources on each subgdb to know which one to use.

Step 3: 

map the data directly using Gex.getData ()

Use case: show all cross-references in a backpage
=================================================

### TODO

Use case: check that IdCodePair exists in current Gdb during import
===================================================================

### TODO

Use case: add a gene to a pathway with gex loaded
=================================================

### TODO: event system for when genes are added to pwy


Importing Gex data
==================

Menu item "create new expression dataset":
after loading the first expression data, a new item will be added
"add more expression data to current dataset"
This way you can have your expression data and your metabolite data, and one can be added after another

potential problems: what if the No of samples is not the same? What if they are in a different order?
