RFC: Gene database & Gex API

This RFC is there to solve these problems:

1. You can load only one gene database per time, however, it would be nice to be able to 
use a gene database and a metabolite database side by side.

2. The current class interface for accessing Gdb & Gex is not well defined, 
for the future we should have a stable API.

3. Modeless caching: the data caching on pathway load popup can be improved, 
a modeless, threaded implementation is preferable.

Roadmap
=======

Step 1: discuss this RFC
Step 2: write class structure with (empty) methods, write javadoc
Step 3: write implementation
in parallel with
Step 4: write unit tests

Step 5: mark old functions as deprecated with pointer to new functions
Step 6: remove deprecated functions one by one. Check that all functionality is covered in new API.

These classes should all be in package org.pathvisio.data

I propose to do a test implementation first in 
	
package org.pathvisio.newdata;

and later move it to 

package org.pathvisio.data;

That way the current and future implementations can live side by side
until we are sure that the new implementation is at least as good as the
current one.

The unit tests should include speed tests for the old and new system so we
can prevent performance regressions.

The implementation will work both with Gdb schema 2 and 3 (See rfc 010-gdb-schema-update)

Naming conventions
==================

System Code <-> Data Source

Data Source is used in GPML.
System Code is used in GenMAPP.

I propose to use Data Source for the concept in general (i.e. a resource for linking pathway datanodes to expression data), 
and SystemCode only when you refer to the one or two letter code such as 'En' or 'L'.

Interface
=========

DataSource.java
---------------
/**
	contains information about a certain DataSource, e.g.
	
	Extenisble enum pattern.
	You can't instantiate this directly, instead you have to use the "getBySystemcode" or "getByFullname" methods.
	These methods return a predefined DataSource object if it exists, or create a new one if necessary.
	
	This way any number of pre-defined DataSources can be used, but plugins can define new ones and you can
	handle unknown systemcodes that occur in Gpml in the same way as predefined ones.
	
	PathVisio should never have to refer to system codes as Strings, except
	- in low level SQL code dealing with Gdb's, Gex and MAPP's (MAPPFormat.java)
	- in low level GPML code (GPMLFormat.java)
*/
public class DataSource
{
	/** turn id into url pointing to info page on the web, e.g. "http://www.ensembl.org/get?id=ENSG..." */
	public Url getUrl(String id); 
	
### TODO: we may want to store patterns in a separate class?	
	/** regular expression for identifying this type of systemcode, e.g. "ENSG\d+" */
	public Pattern getPattern();
	
	/** returns full name of datasource e.g. "Ensembl". May return null. Also used as identifier in GPML */
	public String getFullname(); 
	
	/** returns GenMAPP SystemCode, e.g. "En". May return null. */
	public String getSystemCode(); 
	
	/** so new system codes can be added easily by plugins. Pattern and url may be null */
	public static void register(String fullName, String sysCode, String Pattern, String url);
	
	/** returns pre-existing DataSource object by system code, if it exists, or creates a new one */
	public static DataSource getBySystemcode();

	/** returns pre-existing DataSource object by system code, if it exists, or creates a new one */
	public static DataSource getByFullname();
	
	/**
		get all registered datasoures as a set
		There is no function to get systemcodes or full names as a list of strings, 
		because it's hard to guarantee the ordering, which is needed for combobox controls.
	*/ 
	static public Set<DataSource> getDataSources()
	
}
	
IdCodePair.java
---------------
### TODO: IdCodePair -> good name? Code does not directly refer to datasource
public class IdCodePair
{
	public DataSource getDataSource()
	public void setDataSource (DataSource value)
	
	public String getId()
	public void setId (String value)
	
	public IdCodePair (String id, DataSource ds)
	
	// convenience method
	public Url getUrl ()
	{
		return ds.getUrl(id);
	}
}

Gdb.java
--------
/**
	Abstract interface for dealing with any system that can map from one DataSource to another.
	
	Implementations include: single (derby) database, aggregate database, etc.
*/
abstract class Gdb
{
	/**
	get all cross-references
	*/
	List<IdCodePair> getCrossReferences(IdCodePair icp) throws GdbException
	
	/**
	get cross-references in the target datasource
	(if the target datasource is known the query can usually be optimized)
	*/
	List<IdCodePair> getCrossReferences(IdCodePair icp, DataSource targetDs) throws GdbException
}

GdbException.java
-----------------
/**
	Simple wrapper so using classes don't need to deal with implemenation details
	of the Gdb. Usually wraps SQLException, ClassNotFoundException, etc.
*/
class GdbException
{
}

AggregateGdb.java
-----------------
/**
AggregateGdb: multiple simple Gdb's can be bound together

*/
class AggregateGdb extends Gdb
{
	/**
		constructor, start with empty aggregate
	*/
	public AggregateGdb()
	
	/**
		let a SimpleGdb be registered within the aggregate
	*/
	public void register (SimpleGdb gdb)
	
	@override
	public List<IdCodePair> getCrossReferences(IdCodePair icp, DataSource targetDs) throws GdbException

	@override
	public List<IdCodePair> getCrossReferences(IdCodePair icp) throws GdbException
}

SimpleGdb.java
--------------

class SimpleGdb extends Gdb
{
	/**
		list all available data sources
		(package private method, used by aggregateGdb to find the most suited simpleGdb)
	*/
	Set<DataSource> getAvailableDataSources ()
	
	/**
		Constructor from file
	*/
	SimpleGdb (File file) throws GdbException

	@override
	List<IdCodePair> getCrossReferences(IdCodePair icp, DataSource targetDs) throws GdbException

	@override
	List<IdCodePair> getCrossReferences(IdCodePair icp) throws GdbException
}

Gex.java
--------

abstract class Gex
{
	/**
		returns all data for this codepair and column, 
		mapped by code pair as it in in the expression data.
	*/
### TODO: return type?
	Map<IdCodePair, Object> getData (IdCodePair, String sampleColumn)
}

### TODO: do we need to define data events for mapping newly added genes, caching?

Use case: Mapping data to genes
===============================

Step 1:

### TODO...

Step 2:

AggregateGdb will execute this query for each registered Gdb, and aggregate the results.
It will use getAvailableDatasources on each subgdb to know which one to use.

Step 3: 

map the data directly using Gex.getData ()

Use case: show all cross-references in a backpage
=================================================

### TODO

Use case: check that IdCodePair exists in current Gdb during import
===================================================================

### TODO

Use case: add a gene to a pathway with gex loaded
=================================================

### TODO: event system for when genes are added to pwy


Importing Gex data
==================

Menu item "create new expression dataset":
after loading the first expression data, a new item will be added
"add more expression data to current dataset"
This way you can have your expression data and your metabolite data, and one can be added after another

potential problems: what if the No of samples is not the same? What if they are in a different order?