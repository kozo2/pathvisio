== RFC 002: Connectors ==
This RFC contains a proposal on how to support for more flexible connectors and better
support for editing Molecular Interaction Maps.

== Object anchors ==
All lines will be potential connectors and snap to an object if close enough.
A line end can snap to an anchor point on the object, e.g. the centers of the four sides:

----o----
|       |
o       o
|       |
----o----

The object's anchor points will not be stored in GPML. In the code, the view part of the 
object provides the possible anchor points to the line. We can extend this later to
support custom anchors, set by the user.

== Line anchors ==
To properly represent mediators of interactions/reactions, we need to be able to
connect a connector to another connector, e.g.:

            Enzyme
               |
               |
               v
Substrate -----o-----> Product
             (0.5)

Here we introduce a line anchor, which is similar to the object anchor, except that
this anchor is stored in GPML. We need to store this, because the anchor will be explicitely
created by the user as a specific point on the line. The line anchor's coordinates are 1-dimensional
and range from 0 (start) to 1 (end).

== Elbow connectors ==
To improve the layout of pathways we will support elbow connectors.
The first or last segment always comes in or out of the object either in the x or y direction. 
By following this rule, there can be 0, 1 or 2 middle segments:

Gene1 -------------
                  |
                  |
                  v
               Gene 2
               
Gene1 ------
           |
           +
           |
           ---->Gene 2

Gene1 -------------------
                        |
                        +
                        |
                Gene2 <--
			
Gene1 ----
         |
         |
         +  	Gene2
         |        |
         |----+----

The position of these middle segments (marked with +) can be changed by the user. 
We can store this information using the coordinates of the + points (waypoints).

Often it a given connector can be rendered in two ways:

Gene1 -------------
                   |
                   |
                   v
                Gene 2
 
 Gene1
   |
   |
   |
   ------------->   Gene 2

(Even with waypoints this problem can exist)

The proposed solution is to determine the direction of the connectors at the
start and end-point automatically. This can be done as follows (pseudo-code):

relx = connector.startx - shape.centerx
rely = connector.starty - shape.centery

if (abs (relx) > abs (rely))
{
	if (relx > 0)
		direction = east
	else
		direction = west
}
else
{
	if (rely > 0)
		direction = south
	else
		direction = north
}

== Curved connectors ==

Because people can't seem to live without them, we will also add support
for a curved bend style:

Gene 1  -- 
          \
          |
          +
          |
          \
           --> Gene 2 

This will be similar to the elbow bends, but now the line will curve smoothly
through the waypoint(s).

== Changes to GPML ==
We will introduce the following new attributes and elements:
- Line.Type = [straight, elbow, curved]
	The connector type, 'straight' will be default.
- Line.Anchor
	Optional line anchor point (a line may have multiple anchor points).
- Line.Anchor.X
	The coordinate of the anchor point (relative to the line).
- Line.Anchor.GraphId
	The GraphId of the anchor point.
- Line.Waypoint
	A waypoint for the elbow/curved connector.
- Line.Waypoint.Position
	The position of the waypoint. Depending on the directon of the segment
	this will be the x or y coordinate through which the segment will
	be drawn.

All are optional, so the changes will be backwards compatible.

Here's an example of the GPML code:

<DataNode GraphId="a" TextLabel="Gene1"/>
<DataNode GraphId="b" TextLabel="Gene2"/>
<DataNode GraphId="c" TextLabel="Gene3"/>
<Line Type="elbow">
	<Point GraphRef="a" X="200" Y="200"/>
	<Point GraphRef="b" X="500" Y="500"/>
	<Anchor X="0.2" GraphId="d"/>
	<Waypoint Position="300"/>
</Line>
<Line>
	<Point GraphRef="c" X="300" Y="100"/>
	<Point GraphRef="d" X="300" Y="200"/>
</Line>

Which will be drawn like this:

       Gene 3
          |
          v
Gene1 ----o--
            |
            +
            |
            ----> Gene 2

== Point coordinates of connectors ==

In the current implementation, line ends are not really linked to an object anchor, but have their own coordinates which need to be updated when moving the object.
Maybe it would be better to store the coordinate relative to the object when a point is part of a connector. So in this case, the Point.X and Point.Y attributes can have two meanings:
1. The point has no GraphRef (no connector), the coordinates are relative to the canvas
2. The point has a GraphRef (connector), the coordinates are relative to the object to which is linked

This way we don't have to update all linked points every time an object is moved. The object then doesn't need to have a notion of linked points, which improves modularity and performance.

The xsd needs to change to handle these relative coordinates. This can be done as follows:

<Point X="1750" Y = "3100" GraphId = "abc"/>

becomes

<Point RelX="50" RelY = "25" GraphId = "abc"/>

Points that do not have a graphId can still use X and Y attributes. Points that do
have a graphId have to use RelX and RelY. You can either specify X and Y but not GraphId or
RelX and RelY and GraphId. This will be enforced in GPML.xsd.
For backwards compatibility, we can support reading X and Y and GraphId,
but then immediately the relative coordinates are calculated and used for writing.

(I think relative coordinates may also be useful for groups...)

== Changes to the code ==
TODO
